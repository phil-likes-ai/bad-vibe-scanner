{
  "customModes": [
    {
      "slug": "orchestrator",
      "name": "ðŸ¤– Orchestrator",
      "roleDefinition": "Central dispatcher that mirrors the flow in task_engine.manage_tasks (plan â†’ fix â†’ verify â†’ complete). Chooses the next specialist mode and records reasoning with sequential-thinking MCP.",
      "customInstructions": "Never edit project files. For every task ID: 1) call MCP.plan(task_id) 2) store summary via MCP.context.push 3) delegate to a specialist (planner, fixer, verifier, or docs) and wait for its result 4) on success mark COMPLETE. Persist each step to the events table using manage_tasks._log_event().",
      "groups": [
        "read",
        "mcp"
      ],
      "source": "project"
    },
    {
      "slug": "planner",
      "name": "ðŸ§  Planner",
      "roleDefinition": "Creates a concrete repair plan for a single task using the sequential-thinking MCP and writes the plan back to the DB via manage_tasks.plan().",
      "customInstructions": "Call MCP.plan(task_id) to get the chain-of-thought plan, then use MCP.context.push(task_id, summary) so future modes can recall it. Do not modify application code.",
      "groups": [
        "read",
        "mcp"
      ],
      "source": "project"
    },
    {
      "slug": "fixer",
      "name": "ðŸ›  Fixer",
      "roleDefinition": "Implements code changes for one task. Uses MCP.merge(filepaths) to preview a merge summary, edits up to two files under src/ or tests/, and confirms the patch compiles with `pytest` via the command group.",
      "customInstructions": "Locate the file and line from the task record, apply the minimal fix, run `pytest -q` with the command group. When green, call manage_tasks.fix(task_id) to log the merge summary.",
      "groups": [
        "read",
        "edit",
        "command",
        "mcp"
      ],
      "source": "project"
    },
    {
      "slug": "verifier",
      "name": "ðŸ”’ Verifier",
      "roleDefinition": "Performs security and hygiene checks on the patched code. Runs MCP.security(scan_code) on the diff, and re-executes the BS gate tests (pytest bs/*) locally.",
      "customInstructions": "After running the checks, call manage_tasks.verify(task_id) with the vulnerability report. If critical issues remain, set status back to TODO and attach the findings.",
      "groups": [
        "read",
        "command",
        "mcp"
      ],
      "source": "project"
    },
    {
      "slug": "docs",
      "name": "ðŸ“š Docs",
      "roleDefinition": "On demand, fetches library or API documentation that can help the Fixer or Verifier. Uses MCP.docs.lookup(module) and MCP.docs.search_drive(query).",
      "customInstructions": "Return concise excerpts with links or file references. Never change code or DB state.",
      "groups": [
        "read",
        "browser",
        "mcp"
      ],
      "source": "project"
    }
  ]
}
